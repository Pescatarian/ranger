<!DOCTYPE html>
<html>
<head>
    <title>Ranger</title>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
       body {
    background-color: #1a1a1a;
    color: #4CAF50;
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 20px;
    display: flex;
    user-select: none;
}

/* Main Container Styles */
.main-container {
    flex: 1;
    padding: 20px;
}

.grid-container {
    display: grid;
    grid-template-columns: repeat(40, 65px);
    gap: 0; /* Changed from 1px to 0 */
    background-color: #2d2d2d;
    padding: 1px;
    width: fit-content;
    height: fit-content;
    overflow: auto;
}

.cell {
    width: 65px; /* Changed from 100px */
    height: 28px; /* Changed from 100px */
    background-color: #1a1a1a;
    border: 1px solid #444;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    cursor: pointer;
}

.cell-content {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.context-menu {
    position: fixed;
    background: #2d2d2d;
    border: 1px solid #444;
    padding: 5px 0;
    z-index: 1000;
    min-width: 150px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}

.context-menu-item {
    padding: 8px 15px;
    cursor: pointer;
    color: white;
    display: flex;
    align-items: center;
    gap: 8px;
    position: relative;
}

.context-menu-item:hover {
    background: #3d3d3d;
}

.menu-icon {
    width: 20px;
    text-align: center;
}

.has-submenu .submenu-arrow {
    margin-left: auto;
    font-size: 10px;
}

.color-submenu {
    position: fixed;
    background: #2d2d2d;
    border: 1px solid #444;
    padding: 8px;
    z-index: 1001;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}
        
/* Button Styles */
.button {
    padding: 8px 16px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin: 5px;
    transition: all 0.3s ease;
    position: relative;
    z-index: 1001;
}
        
.button.active {
    background-color: #45a049;
    box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
    border: 2px solid #fff;
    transform: scale(1.05);
}

/* Range Builder Sidebar */
.sidebar {
    width: 600px;
    background-color: #2d2d2d;
    padding: 10px;
    border-left: 1px solid #444;
    display: none;
    position: fixed;
    right: 0;
    top: 0;
    height: 100vh;
    flex-direction: column;
    align-items: center;
}

.sidebar h2 {
    color: #4CAF50;
    margin-top: 20px;
    width: 100%;
    padding-left: 20px;
}

/* View Controls */
.view-controls {
    width: 520px;
    display: flex;
    gap: 8px;
    margin: 3px auto;
    padding: 3px 0;
    justify-content: center;
}

.view-button {
    padding: 6px 12px;
    min-width: 70px;
    background-color: #2d2d2d;
    color: #4CAF50;
    border: 1px solid #444;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
}

.view-button.active {
    background-color: #4CAF50;
    color: white;
    border-color: white;
}

/* Range Grid */
.range-grid {
    display: grid;
    grid-template-columns: repeat(13, 1fr);
    gap: 1px;
    margin: 8px auto;
    width: 520px;
    aspect-ratio: 1;
    margin-bottom: 8px;
}

.range-cell {
    aspect-ratio: 1;
    background-color: #1a1a1a;
    border: 1px solid #444;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    cursor: pointer;
    color: white;
    position: relative;
    overflow: hidden;
}

.range-cell:hover {
    background-color: #2d2d2d;
}

.range-cell.selected {
    color: white;
    position: relative;
    z-index: 1;
    transition: background 0.3s ease;
}

.range-cell span {
    z-index: 2;
    position: relative;
}

/* Controls Layout */
.controls {
    position: fixed;
    top: 20px;
    right: 20px;
    display: flex;
    gap: 10px;
    z-index: 1000; /* Ensure buttons are above everything */
    background: transparent; /* Remove any background */
}

/* Row Controls */
.top-controls {
    width: 520px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin: 10px auto;
    padding: 0;
    background-color: #2d2d2d;
    border-radius: 4px;
}

.control-row {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 520px;
    padding: 4px 0;
    border-radius: 4px;
    background-color: #1a1a1a;
    gap: 12px;
    opacity: 0.7;
}
        
.control-row.active {
    opacity: 1;
}

/* Row Toggle Button */
.row-toggle {
    min-width: 20px;
    min-height: 20px;
    width: 20px;
    height: 20px;
    background-color: #2d2d2d;
    border: 2px solid #666;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s ease;
    padding: 0;
    font-size: 0;
    position: relative;
    display: inline-block;
    flex: 0 0 20px;
}

.row-toggle.active {
    border-color: #4CAF50;
    box-shadow: 0 1px 3px rgba(76,175,80,0.6);
}

.row-toggle.active::after {
    content: '';
    position: absolute;
    width: 10px;
    height: 10px;
    background-color: #4CAF50;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    top: 50%;
    left: 50%;
}

/* Stat Boxes and Groups */
.stat-box {
    position: relative;
    display: flex;
    align-items: center;
    gap: 3px;
    color: #4CAF50;
    white-space: nowrap;
    margin-right: 15px;  /* Add spacing between stat boxes */
}

.weight-input {
    background-color: #1a1a1a;
    color: #4CAF50;  /* Change from white to match other text */
    border: 1px solid #444;
    width: 45px;
    height: 25px;
    text-align: center;
    padding: 0 5px;
}

/* Color Picker Styles */
.color-picker-panel {
    position: fixed;
    background: #2d2d2d;
    border: 1px solid #444;
    border-radius: 4px;
    padding: 8px;
    width: 220px;
    display: none;
    z-index: 1000;
    box-shadow: 0 2px 10px rgba(0,0,0,0.5);
}

.color-picker-panel.active {
    display: block;
}

.color-picker-header {
    padding: 4px;
    cursor: move;
    text-align: center;
    border-bottom: 1px solid #444;
    margin-bottom: 8px;
    color: #fff;
}

.color-section {
    margin-bottom: 12px;
    padding-bottom: 12px;
    border-bottom: 1px solid #444;
}

.color-section:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.section-label {
    color: #fff;
    font-size: 12px;
    margin-bottom: 8px;
    font-weight: 500;
}

.theme-colors-grid,
.standard-colors-grid,
.recent-colors-grid {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    gap: 0;
    margin-top: 4px;
    position: relative; /* Add this */
}

.color-swatch {
    width: 100%;
    aspect-ratio: 1;
    border: none;
    cursor: pointer;
    position: relative; /* Add this */
}

.color-swatch:hover {
    outline: 1px solid #fff; /* Use outline instead of border */
    outline-offset: 0;
    z-index: 1;
}

.color-swatch-button {
    width: 25px;
    height: 25px;
    padding: 0;
    border: 1px solid #444;
    background: #1a1a1a;
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.current-color {
    width: 100%;
    height: 100%;
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    border: 1px solid rgba(255,255,255,0.2);
}

.color-options {
    display: flex;
    justify-content: flex-start;
}

.option-button {
    background: #1a1a1a;
    border: 1px solid #444;
    color: white;
    cursor: pointer;
    display: inline-block;
    padding: 4px 8px;
}
      
/* Range Text Box */
.range-text {
    width: 520px;
    height: 80px;
    background-color: #1a1a1a;
    color: #4CAF50;
    border: 1px solid #444;
    padding: 8px;
    margin: 3px auto;
    font-family: Arial, sans-serif;
    resize: none;
    box-sizing: border-box;
}

/* Bottom Buttons */
.button-container {
    width: 520px;
    display: flex;
    justify-content: space-between;  /* This will push Clear to the right */
    margin: 3px auto;
    gap: 10px;
}
        
.save-button, .clear-button {
    width: 100px;
    height: 35px;
    padding: 0;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    color: white;
    font-weight: bold;
    line-height: 35px;
}

.save-button {
    background-color: #4CAF50;
}

.clear-button {
    background-color: #ff4444;
}

/* Replace the current .format-switch CSS with this */
.format-switch {
    position: relative;
    width: 60px;
    height: 30px;
    margin: 2.5px 10px;
    background-color: #1d1d1d;
    border-radius: 15px;
    border: 1px solid #444;
    cursor: pointer;
    display: flex;
    align-items: center;
    padding: 0 5px;
}

.format-switch::before {
    content: '';
    position: absolute;
    width: 24px;
    height: 24px;
    border-radius: 12px;
    background-color: #4CAF50;
    left: 2px;
    transition: transform 0.3s;
}

.format-switch.format-2::before {
    transform: translateX(30px);
}

.format-switch::after {
    position: absolute;
    color: #4CAF50;
    font-size: 12px;
    font-weight: bold;
    left: 9px;
}

.format-switch.format-2::after {
    left: auto;
    right: 9px;
}

/* Add this CSS */
.three-way-switch {
    width: 180px;
    height: 34px;
    background-color: #1d1d1d;
    border-radius: 17px;
    position: relative;
    cursor: pointer;
    border: 1px solid #444;
    margin: 3px auto;
}

.switch-handle {
    width: 60px;
    height: 28px;
    background-color: #4CAF50;
    border-radius: 14px;
    position: absolute;
    top: 2px;
    left: 60px; /* Middle position by default */
    transition: left 0.3s ease;
}

.switch-labels {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 10px;
    color: white;
    font-size: 13px;
    position: relative;
    z-index: 2;
}

.switch-labels span {
    flex: 1;
    text-align: center;
    user-select: none;
}

/* Handle positions */
.three-way-switch[data-view="row1"] .switch-handle {
    left: 2px;
}

.three-way-switch[data-view="all"] .switch-handle {
    left: 60px;
}

.three-way-switch[data-view="row2"] .switch-handle {
    left: 118px;
}
    
/* Hover Effects */
.view-button:hover:not(.active),
.row-toggle:hover:not(.active) {
    background-color: #3d3d3d;
}

.range-popup {
    background: #fff;
    border: 1px solid #444;
    border-radius: 2px;
    padding: 2px;
    position: fixed;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    display: none;  /* Add this line */
}

.range-popup img {
    max-width: 400px;
    height: auto;
}

.cell-content.has-range::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    border-style: solid;
    border-width: 0 8px 8px 0;
    border-color: transparent #4CAF50 transparent transparent;
}
        
   </style>
</head>
<body>
    <div class="main-container">
        <div class="controls">
            <button id="viewModeBtn" class="button active" onclick="toggleViewMode()">View Mode</button>
            <button id="rangeBuilderBtn" class="button" onclick="toggleRangeBuilder()">Range Builder</button>
            <button id="exportJsonBtn" class="button" onclick="exportToJson()">Export JSON</button>
            <input type="file" id="jsonFileInput" accept=".json" style="display: none;" onchange="importFromJson(event)">
            <button id="importJsonBtn" class="button" onclick="document.getElementById('jsonFileInput').click()">Import JSON</button>
        </div>
        <div class="grid-container" id="grid"></div>
    </div>

    <div class="sidebar" id="sidebar">
        <h2>Range Builder</h2>
        
        <!-- View Mode Controls -->
        <div class="view-controls">
            <div class="three-way-switch">
                <div class="switch-handle"></div>
            </div>  <!-- Missing closing div for three-way-switch -->
        </div>     <!-- Missing closing div for view-controls -->

        <div class="range-grid" id="rangeGrid"></div>
        
        <!-- Control Rows Container -->
        <div class="top-controls">
            <!-- First Control Row -->
            <div class="control-row active">
                <button class="row-toggle active" data-row="1">Row 1</button>
                
                <div class="stat-box">
                    <span>Color</span>
                    <div class="color-picker-container">
                        <button class="color-swatch-button" id="colorPicker1">
                            <span class="current-color" style="background-color: #4CAF50"></span>
                        </button>
                        <div class="color-picker-panel">
                            <div class="color-section">
                                <div class="section-label">Theme Colors</div>
                                <div class="theme-colors-grid"></div>
                            </div>
                            <div class="color-section">
                                <div class="section-label">Standard Colors</div>
                                <div class="standard-colors-grid"></div>
                            </div>
                            <div class="color-section">
                                <div class="section-label">Recent Colors</div>
                                <div class="recent-colors-grid"></div>
                            </div>
                            <div class="color-options">
                                <button class="option-button more-colors">More Colors...</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="stat-box">
                    <span>W%</span>
                    <input type="number" id="weightInput1" value="100" min="0" max="100" 
                           class="weight-input stat-value" onchange="updateWeight(this.value, 1)">
                </div>
                
                <div class="stat-box">
                    <span>Range</span>
                    <span id="rangePercent1" class="stat-value">0</span>
                </div>
                
                <div class="stat-box">
                    <span>Combos</span>
                    <span id="comboCount1" class="stat-value">0</span>
                </div>
            </div>

            <!-- Second Control Row -->
            <div class="control-row">
                <button class="row-toggle" data-row="2">Row 2</button>
                
                <div class="stat-box">
                    <span>Color</span>
                    <div class="color-picker-container">
                        <button class="color-swatch-button" id="colorPicker2">
                            <span class="current-color" style="background-color: #FF0000"></span>
                        </button>
                        <div class="color-picker-panel">
                            <div class="color-picker-header">⋮⋮</div>
                            <div class="color-section">
                                <div class="section-label">Theme Colors</div>
                                <div class="theme-colors-grid"></div>
                            </div>
                            <div class="color-section">
                                <div class="section-label">Standard Colors</div>
                                <div class="standard-colors-grid"></div>
                            </div>
                            <div class="color-section">
                                <div class="section-label">Recent Colors</div>
                                <div class="recent-colors-grid"></div>
                            </div>
                            <div class="color-options">
                               <button class="option-button more-colors">More Colors...</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="stat-box">
                    <span>W%</span>
                    <input type="number" id="weightInput2" value="100" min="0" max="100" 
                           class="weight-input stat-value" onchange="updateWeight(this.value, 2)">
                </div>
                
                <div class="stat-box">
                    <span>Range</span>
                    <span id="rangePercent2" class="stat-value">0</span>
                </div>
                
                <div class="stat-box">
                    <span>Combos</span>
                    <span id="comboCount2" class="stat-value">0</span>
                </div>
            </div>
        </div>

        <textarea id="rangeText" class="range-text" 
                  oninput="handleRangeTextChange(event)"></textarea>
        
        <div class="button-container">
            <button class="save-button" onclick="saveToCell()">Save to Cell</button>
            <button class="format-switch" id="formatSwitch"></button>
            <button class="clear-button" onclick="clearSelection()">Clear</button>
        </div>
    </div>

    <script>
        
// Variables and Constants
let isViewMode = true;
let isRangeBuilderOpen = false;
let selectedCell = null;
const cellData = new Map();
const MAX_RECENT_COLORS = 10;
let currentWeights = [100, 100];
let currentColors = ['#4CAF50', '#FF0000'];
let activeRow = 0;
let isMouseDown = false;
let isSelecting = null;
let currentView = 'all';
let recentColors = JSON.parse(localStorage.getItem('recentColors') || '[]');
let colorPickerPosition = JSON.parse(localStorage.getItem('colorPickerPosition') || '{"x": 0, "y": 0}');
let isDragging = false;
let dragStartX, dragStartY;
let clipboardData = null;
let currentFormat = 1; // 1 for decimal format, 2 for bracket format
let exportInProgress = false;
        
// Create a single reusable popup element
const hoverPopup = document.createElement('div');
hoverPopup.className = 'range-popup';
document.body.appendChild(hoverPopup);
        
// Color Palettes
const themeColors = [
    ['#FFFFFF', '#000000', '#4472C4', '#5B9BD5', '#ED7D31', '#70AD47', '#7030A0', '#00B0F0', '#FFC000', '#FFD966'],
    ['#F2F2F2', '#7F7F7F', '#D9E2F3', '#DEEBF7', '#FBE5D6', '#E2EFD9', '#E4D9EC', '#DBEEF3', '#FFF2CC', '#FFECB3'],
    ['#D8D8D8', '#595959', '#B4C6E7', '#BDD7EE', '#F7CBAC', '#C6E0B4', '#CDB9DE', '#B7DDE8', '#FFE699', '#FFD966'],
    ['#BFBFBF', '#3F3F3F', '#8EAADB', '#9CC3E5', '#F4B183', '#A9D18E', '#B2A1C7', '#92CDDC', '#FFD966', '#FFD966'],
    ['#A5A5A5', '#262626', '#2F5496', '#2E75B5', '#C55A11', '#538135', '#7030A0', '#31859B', '#BF9000', '#FFD966'],
    ['#7F7F7F', '#0C0C0C', '#1F3864', '#1F4E79', '#833C0C', '#375623', '#4C1F6C', '#205867', '#7F6000', '#FFD966']
];

const standardColors = [
    '#C00000', '#FF0000', '#FFC000', '#FFD966', '#92D050', '#00B050', '#00B0F0', '#0070C0', '#002060', '#7030A0'
];

// Color Picker Core Functions
function handleColorPickerClick(e) {
    const button = e.currentTarget;
    const panel = button.nextElementSibling;
    const rowIndex = button.id === 'colorPicker1' ? 0 : 1;

    // Close any other open panels
    document.querySelectorAll('.color-picker-panel').forEach(p => {
        if (p !== panel) p.classList.remove('active');
    });

    // Toggle current panel
    panel.classList.toggle('active');

    if (panel.classList.contains('active')) {
        // Position the panel
        positionColorPicker(panel, button);

        // Generate colors if not already done
        if (!panel.dataset.initialized) {
            generateColorPalette(panel, rowIndex);
            panel.dataset.initialized = 'true';
        }
    }

    // Close panel when clicking outside
    const closePanel = (event) => {
        if (!panel.contains(event.target) && event.target !== button) {
            panel.classList.remove('active');
            document.removeEventListener('click', closePanel);
        }
    };
    
    setTimeout(() => {
        document.addEventListener('click', closePanel);
    }, 0);
}

function generateColorPalette(panel, rowIndex) {
    // Generate theme colors
    const themeGrid = panel.querySelector('.theme-colors-grid');
    themeColors.forEach(row => {
        row.forEach(color => {
            const swatch = createColorSwatch(color, rowIndex);
            themeGrid.appendChild(swatch);
        });
    });

    // Generate standard colors
    const standardGrid = panel.querySelector('.standard-colors-grid');
    standardColors.forEach(color => {
        const swatch = createColorSwatch(color, rowIndex);
        standardGrid.appendChild(swatch);
    });

    // Update recent colors
    updateRecentColorsPanel(panel);
}

function createColorSwatch(color, rowIndex) {
    const swatch = document.createElement('div');
    swatch.className = 'color-swatch';
    swatch.style.backgroundColor = color;
    swatch.dataset.color = color;
    swatch.dataset.rowIndex = rowIndex;
    return swatch;
}
function selectColor(color, rowIndex) {
    // Update color immediately
    currentColors[rowIndex] = color;
    
    // Update visual immediately
    const button = document.getElementById(`colorPicker${rowIndex + 1}`);
    button.querySelector('.current-color').style.backgroundColor = color;

    // Add to recent colors efficiently
    addToRecentColors(color);
    
    // Update everything else
    updateRangeDisplay(currentView);
    saveColorSettings(rowIndex);

    // Close panel
    const panel = button.nextElementSibling;
    panel.classList.remove('active');
}

function addToRecentColors(color) {
    // Remove if already exists
    const index = recentColors.indexOf(color);
    if (index > -1) {
        recentColors.splice(index, 1);
    }
    
    // Add to front
    recentColors.unshift(color);
    
    // Keep only MAX_RECENT_COLORS
    if (recentColors.length > MAX_RECENT_COLORS) {
        recentColors.pop();
    }
    
    // Save to localStorage
    localStorage.setItem('recentColors', JSON.stringify(recentColors));
    
    // Update all panels
    document.querySelectorAll('.color-picker-panel').forEach(updateRecentColorsPanel);
}

function updateRecentColorsPanel(panel) {
    const recentGrid = panel.querySelector('.recent-colors-grid');
    const section = recentGrid.closest('.color-section');
    
    if (recentColors.length === 0) {
        section.style.display = 'none';
        return;
    }

    section.style.display = 'block';
    recentGrid.innerHTML = '';
    
    const rowIndex = panel.closest('.control-row').dataset.row - 1;
    recentColors.forEach(color => {
        const swatch = createColorSwatch(color, rowIndex);
        recentGrid.appendChild(swatch);
    });
}

// Position and Dragging Functions
function positionColorPicker(panel, button) {
    const buttonRect = button.getBoundingClientRect();
    const panelRect = panel.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;

    // If we have a saved position, use it
    if (colorPickerPosition.x !== 0 || colorPickerPosition.y !== 0) {
        panel.style.position = 'fixed';
        panel.style.left = `${colorPickerPosition.x}px`;
        panel.style.top = `${colorPickerPosition.y}px`;
        return;
    }

    // Otherwise, calculate the best position
    let left = buttonRect.left;
    let top = buttonRect.bottom + 5;

    // Check if panel would go off the bottom of the screen
    if (top + panelRect.height > viewportHeight) {
        top = buttonRect.top - panelRect.height - 5;
    }

    // Check if panel would go off the right of the screen
    if (left + panelRect.width > viewportWidth) {
        left = viewportWidth - panelRect.width - 5;
    }

    panel.style.position = 'fixed';
    panel.style.left = `${left}px`;
    panel.style.top = `${top}px`;
}

function initializeDragging() {
    document.querySelectorAll('.color-picker-panel').forEach(panel => {
        // Add draggable header
        const header = document.createElement('div');
        header.className = 'color-picker-header';
        header.innerHTML = '⋮⋮'; // Drag handle icon
        panel.insertBefore(header, panel.firstChild);

        header.addEventListener('mousedown', startDragging);
    });
}

function startDragging(e) {
    const panel = e.target.closest('.color-picker-panel');
    isDragging = true;
    dragStartX = e.clientX - panel.offsetLeft;
    dragStartY = e.clientY - panel.offsetTop;

    const moveHandler = (e) => {
        if (isDragging) {
            const x = e.clientX - dragStartX;
            const y = e.clientY - dragStartY;
            panel.style.left = `${x}px`;
            panel.style.top = `${y}px`;
            colorPickerPosition = { x, y };
            localStorage.setItem('colorPickerPosition', JSON.stringify(colorPickerPosition));
        }
    };

    const upHandler = () => {
        isDragging = false;
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('mouseup', upHandler);
    };

    document.addEventListener('mousemove', moveHandler);
    document.addEventListener('mouseup', upHandler);
}

// Grid Creation Functions
function createGrid() {
    const grid = document.getElementById('grid');
    for (let i = 0; i < 40; i++) {
        for (let j = 0; j < 40; j++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            const cellId = `${String.fromCharCode(65 + j)}${i + 1}`;
            
            const cellContent = document.createElement('div');
            cellContent.className = 'cell-content';
            
            cell.appendChild(cellContent);
            cell.dataset.id = cellId; // Keep this for functionality
            
            cell.addEventListener('click', selectCell);
            cell.setAttribute('draggable', true);
            cell.addEventListener('dragstart', handleDragStart);
            cell.addEventListener('dragover', handleDragOver);
            cell.addEventListener('drop', handleDrop);
            
            makeEditable(cell);
            addContextMenu(cell);
            
            grid.appendChild(cell);
        }
    }
}

function makeEditable(cell) {
    // Single click for selection only
    cell.addEventListener('click', (e) => {
        document.querySelectorAll('.cell').forEach(c => 
            c.style.outline = 'none'
        );
        
        cell.style.outline = '3px solid #4CAF50';
        cell.style.outlineOffset = '-3px';
        selectedCell = cell;
    });

    // Add keyboard shortcuts handler
    document.addEventListener('keydown', (e) => {
        if (selectedCell && (e.key === 'Delete' || e.key === 'Backspace') && !selectedCell.querySelector('input')) {
            e.preventDefault();
            const content = selectedCell.querySelector('.cell-content');
            content.textContent = '';
            cellData.delete(selectedCell.dataset.id);
        }
    }, { passive: false });

    // Double click for editing
    cell.addEventListener('dblclick', (e) => {
        const content = cell.querySelector('.cell-content');
        
        // Only create input if it doesn't exist
        if (!cell.querySelector('input')) {
            const input = document.createElement('input');
            input.type = 'text';
            input.value = content.textContent === '📝' ? '' : content.textContent;
            input.style.cssText = `
                width: 100%;
                height: 100%;
                border: none;
                padding: 0 2px;
                background-color: #1a1a1a;
                color: #4CAF50;
                text-align: center;
            `;
            
            content.innerHTML = '';
            content.appendChild(input);
            input.focus();
            
            const finishEditing = () => {
                const newText = input.value;
                content.innerHTML = newText || '';
                if (newText) {
                    cellData.set(cell.dataset.id, newText);
                } else {
                    cellData.delete(cell.dataset.id);
                }
            };
            
            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                }
                e.stopPropagation();
            });
        }
    });
}

function addContextMenu(cell) {
    cell.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        
        // Remove any existing context menus
        document.querySelectorAll('.context-menu').forEach(menu => menu.remove());
        
        const menu = document.createElement('div');
        menu.className = 'context-menu';
        
        const menuItems = [
            { text: 'Fill Color', icon: '🎨', submenu: true },
            { text: 'Text Color', icon: 'A', submenu: true },
            { text: 'Reset Format', icon: '↺', submenu: false },
            { text: 'Clear Range', icon: '🗑️' }, // Added Clear Range option
            { text: 'Cut', icon: '✂️' },
            { text: 'Copy', icon: '📄' },
            { text: 'Paste', icon: '📋' }
        ];
        
        menuItems.forEach(item => {
            const menuItem = document.createElement('div');
            menuItem.className = 'context-menu-item';
            if (item.submenu) {
                menuItem.classList.add('has-submenu');
            }
            menuItem.innerHTML = `
                <span class="menu-icon">${item.icon}</span>
                <span class="menu-text">${item.text}</span>
                ${item.submenu ? '<span class="submenu-arrow">▶</span>' : ''}
            `;
            
            if (item.submenu) {
                menuItem.addEventListener('mouseover', () => {
                    showColorSubmenu(menuItem, item.text === 'Fill Color');
                });
            } else {
                menuItem.onclick = () => handleContextMenuAction(item.text, cell);
            }
            
            menu.appendChild(menuItem);
        });
        
        // Position the menu at cursor
        menu.style.left = `${e.pageX}px`;
        menu.style.top = `${e.pageY}px`;
        
        document.body.appendChild(menu);
        
        // Close menu when clicking outside
        document.addEventListener('click', () => {
            document.querySelectorAll('.context-menu, .color-submenu').forEach(m => m.remove());
        }, { once: true });
    });
}

function createRangeGrid() {
    const rangeGrid = document.getElementById('rangeGrid');
    const ranks = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2'];
    
    for (let i = 0; i < ranks.length; i++) {
        for (let j = 0; j < ranks.length; j++) {
            const cell = document.createElement('div');
            cell.className = 'range-cell';
            
            const textSpan = document.createElement('span');
            if (i === j) {
                textSpan.textContent = ranks[i] + ranks[j];
            } else if (i < j) {
                textSpan.textContent = ranks[i] + ranks[j] + 's';
            } else {
                textSpan.textContent = ranks[j] + ranks[i] + 'o';
            }
            cell.appendChild(textSpan);

            // Only block cell selection on right click, allow inspect menu
            cell.addEventListener('mousedown', e => {
                if (e.button === 2) return; // Just ignore right clicks for selection
                startRangeSelection(e);
            });
            cell.addEventListener('mouseover', updateRangeSelection);
            
            rangeGrid.appendChild(cell);
        }
    }
    
    document.addEventListener('mouseup', endRangeSelection);
}
      
function showColorSubmenu(menuItem, isFillColor) {
    document.querySelectorAll('.color-submenu').forEach(sub => sub.remove());
    
    const submenu = document.createElement('div');
    submenu.className = 'color-submenu';
    
    // Updated theme colors to match Excel's 10x6 grid
    const themeColors = [
        ['#FFFFFF', '#000000', '#E7E6E6', '#44546A', '#4472C4', '#ED7D31', '#A5A5A5', '#FFC000', '#5B9BD5', '#70AD47'],
        ['#F2F2F2', '#7F7F7F', '#D0CECE', '#D5DCE4', '#D9E2F3', '#FBE5D6', '#EDEDED', '#FFF2CC', '#DEEBF7', '#E2EFD9'],
        ['#D8D8D8', '#595959', '#AEABAB', '#ACB9CA', '#B4C6E7', '#F7CBAC', '#DBDBDB', '#FFE699', '#BDD7EE', '#C6E0B4'],
        ['#BFBFBF', '#3F3F3F', '#757070', '#8496B0', '#8EA9DB', '#F4B183', '#C9C9C9', '#FFD966', '#9CC3E5', '#A9D08E'],
        ['#A5A5A5', '#262626', '#3A3838', '#323F4F', '#2F5496', '#C55A11', '#7B7B7B', '#BF9000', '#2E75B5', '#538135'],
        ['#7F7F7F', '#0C0C0C', '#171717', '#222A35', '#1F3864', '#833C0C', '#525252', '#7F6000', '#1F4E79', '#375623']
    ];

    const colorGrid = document.createElement('div');
    colorGrid.style.cssText = `
        display: grid;
        grid-template-columns: repeat(10, 20px);
        gap: 1px;
        padding: 2px;
    `;

    // Create all swatches at once using DocumentFragment for better performance
    const fragment = document.createDocumentFragment();
    themeColors.forEach(row => {
        row.forEach(color => {
            const swatch = document.createElement('div');
            swatch.style.cssText = `
                width: 20px;
                height: 20px;
                background-color: ${color};
                cursor: pointer;
                border: 1px solid #444;
            `;
            
            swatch.onclick = () => {
                const cell = selectedCell;
                if (isFillColor) {
                    cell.style.backgroundColor = color;
                } else {
                    const content = cell.querySelector('.cell-content');
                    content.style.color = color;
                }
                document.querySelectorAll('.context-menu, .color-submenu').forEach(m => m.remove());
            };
            
            fragment.appendChild(swatch);
        });
    });

    colorGrid.appendChild(fragment);
    submenu.appendChild(colorGrid);

    // Position submenu next to the menu item
    const rect = menuItem.getBoundingClientRect();
    submenu.style.left = `${rect.right}px`;
    submenu.style.top = `${rect.top}px`;

    document.body.appendChild(submenu);
}

function handleContextMenuAction(action, cell) {
    switch(action) {
        case 'Reset Format':
            cell.style.backgroundColor = '';
            cell.querySelector('.cell-content').style.color = '';
            break;
        case 'Clear Range':
            const content = cell.querySelector('.cell-content');
            if (content.dataset.range) {
                clearCell(cell);
            }
            break;
        case 'Cut':
            clipboardData = copyCell(cell);
            clearCell(cell);
            break;
        case 'Copy':
            clipboardData = copyCell(cell);
            break;
        case 'Paste':
            pasteCell(cell, clipboardData);
            break;
    }
    document.querySelectorAll('.context-menu').forEach(m => m.remove());
}
  
// Range Handling Functions
function toggleRangeCell(cell) {
    const activeRowToggle = document.querySelector(`.row-toggle[data-row="${activeRow + 1}"]`);
    if (!activeRowToggle?.classList.contains('active')) return;

    if (!cell.dataset.selections) {
        cell.dataset.selections = JSON.stringify([]);
    }
    
    let selections = JSON.parse(cell.dataset.selections);
    const currentColor = currentColors[activeRow];
    const currentWeight = currentWeights[activeRow];
    
    const otherRowSelections = selections.filter(s => currentColors.indexOf(s.color) !== activeRow);
    const existingSelection = selections.find(s => currentColors.indexOf(s.color) === activeRow);

    if (existingSelection) {
        if (existingSelection.color === currentColor && existingSelection.weight === currentWeight) {
            selections = otherRowSelections;
        } else {
            selections = [...otherRowSelections, { color: currentColor, weight: currentWeight }];
        }
    } else {
        selections = [...otherRowSelections, { color: currentColor, weight: currentWeight }];
    }
    
    cell.dataset.selections = JSON.stringify(selections);
    updateCellVisual(cell);
    updateRangeText();
    updateStats();
}

function updateCellVisual(cell) {
    const selections = JSON.parse(cell.dataset.selections || '[]');
    
    if (selections.length === 0) {
        cell.style.background = '#1a1a1a';
        cell.classList.remove('selected');
        return;
    }

    cell.classList.add('selected');
    
    // For visual display, only show weights from active row
    if (currentView === 'row1') {
        const row1Selection = selections.find(s => s.color === currentColors[0]);
        if (row1Selection) {
            cell.style.background = `linear-gradient(to right, ${currentColors[0]} ${row1Selection.weight}%, #1a1a1a ${row1Selection.weight}%)`;
        } else {
            cell.style.background = '#1a1a1a';
        }
    } 
    else if (currentView === 'row2') {
        const row2Selection = selections.find(s => s.color === currentColors[1]);
        if (row2Selection) {
            cell.style.background = `linear-gradient(to right, ${currentColors[1]} ${row2Selection.weight}%, #1a1a1a ${row2Selection.weight}%)`;
        } else {
            cell.style.background = '#1a1a1a';
        }
    }
    else {
        // Show All view - original combined gradient logic
        if (selections.length === 1) {
            const {color, weight} = selections[0];
            cell.style.background = `linear-gradient(to right, ${color} ${weight}%, #1a1a1a ${weight}%)`;
        } else {
            selections.sort((a, b) => currentColors.indexOf(a.color) - currentColors.indexOf(b.color));
            
            let gradientString = 'linear-gradient(to right, ';
            let currentPosition = 0;
            
            selections.forEach((selection, index) => {
                gradientString += `${selection.color} ${currentPosition}% ${currentPosition + selection.weight}%`;
                currentPosition += selection.weight;
                
                if (index < selections.length - 1) {
                    gradientString += ', ';
                }
            });
            
            gradientString += `, #1a1a1a ${currentPosition}%)`;
            cell.style.background = gradientString;
        }
    }
}

function updateStats() {
    const selectedCells = document.querySelectorAll('.range-cell');
    let totalCombos = [0, 0];
    
    selectedCells.forEach(cell => {
        const hand = cell.querySelector('span').textContent;
        const selections = JSON.parse(cell.dataset.selections || '[]');
        
        if (selections.length === 0) return;
        
        let handCombos = 0;
        if (hand.length === 2) {
            handCombos = 6;
        } else if (hand.endsWith('s')) {
            handCombos = 4;
        } else if (hand.endsWith('o')) {
            handCombos = 12;
        }
        
        selections.forEach(selection => {
            const rowIndex = currentColors.indexOf(selection.color);
            if (rowIndex !== -1) {
                totalCombos[rowIndex] += handCombos * (selection.weight / 100);
            }
        });
    });
    
    const totalPossibleCombos = 1326;
    totalCombos.forEach((combos, index) => {
        const rangePercentage = (combos / totalPossibleCombos * 100).toFixed(1);
        document.getElementById(`rangePercent${index + 1}`).textContent = rangePercentage + '%';
        document.getElementById(`comboCount${index + 1}`).textContent = Math.round(combos);
    });
}

// Now add the JSON export/import functions:
function exportToJson() {
    try {
        // Collect all cell data including ranges, styling, and content
        const cellsData = {};
        document.querySelectorAll('.cell').forEach(cell => {
            const cellId = cell.dataset.id;
            const content = cell.querySelector('.cell-content');
            
            if (content.textContent || content.dataset.range || 
                cell.style.backgroundColor || content.style.color) {
                cellsData[cellId] = {
                    text: String(content.textContent || ''),
                    backgroundColor: String(cell.style.backgroundColor || ''),
                    textColor: String(content.style.color || ''),
                    rangeData: String(content.dataset.range || ''),
                    hasRange: Boolean(content.classList.contains('has-range'))
                };
            }
        });
        
        // Create complete app state object
        const appData = {
            cellsData: cellsData,
            currentColors: [...currentColors],
            currentWeights: [...currentWeights],
            recentColors: [...recentColors],
            currentFormat: Number(currentFormat),
            version: "1.0"
        };
        
        // Create and trigger download
        const dataStr = JSON.stringify(appData, null, 2);
        const blob = new Blob([dataStr], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ranger-data.json';
        document.body.appendChild(a);
        a.click();
        
        // Delay cleanup to ensure download starts
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
    } catch (error) {
        console.error('Export error:', error);
        alert('Error exporting data: ' + error.message);
    }
}

function exportToJson() {
    // Prevent multiple exports in quick succession
    if (exportInProgress) {
        alert("Export already in progress, please wait...");
        return;
    }
    
    exportInProgress = true;
    console.log("Export started, flag set to true"); // Debug logging
    
    try {
        // Collect all cell data including ranges, styling, and content
        // [your existing collection code here]
        
        // Create and trigger download
        const dataStr = JSON.stringify(appData, null, 2);
        const blob = new Blob([dataStr], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ranger-data.json';
        document.body.appendChild(a);
        a.click();
        
        // Reset flag regardless of success/failure after a delay
        setTimeout(() => {
            try {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (cleanupError) {
                console.error("Cleanup error:", cleanupError);
            }
            
            exportInProgress = false;
            console.log("Export completed, flag reset to false"); // Debug logging
        }, 500);
    } catch (error) {
        console.error('Export error:', error);
        alert('Error exporting data: ' + error.message);
        exportInProgress = false; // Reset flag on error
        console.log("Export failed, flag reset to false"); // Debug logging
    }
}
        // Event Handlers and Selection Functions
function startRangeSelection(e) {
    isMouseDown = true;
    const cell = e.target.closest('.range-cell');
    const selections = JSON.parse(cell.dataset.selections || '[]');
    isSelecting = !selections.some(s => s.color === currentColors[activeRow]);
    toggleRangeCell(cell);
}

function updateRangeSelection(e) {
    if (!isMouseDown || isSelecting === null) return;
    const cell = e.target.closest('.range-cell');
    if (!cell) return;
    
    const selections = JSON.parse(cell.dataset.selections || '[]');
    const hasCurrentColor = selections.some(s => s.color === currentColors[activeRow]);
    
    if (hasCurrentColor !== isSelecting) {
        toggleRangeCell(cell);
    }
}

function endRangeSelection() {
    isMouseDown = false;
    isSelecting = null;
}

function handleViewChange(e) {
    document.querySelectorAll('.view-button').forEach(btn => btn.classList.remove('active'));
    e.target.classList.add('active');
    
    currentView = e.target.dataset.view;
    updateRangeDisplay(currentView);
    
    // Update all cell visuals to reflect new view
    document.querySelectorAll('.range-cell').forEach(cell => updateCellVisual(cell));
    
    // Update text output to match current view
    updateRangeText();
}

function handleRowToggle(e) {
    document.querySelectorAll('.row-toggle').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.control-row').forEach(row => row.classList.remove('active'));
    
    e.target.classList.add('active');
    e.target.closest('.control-row').classList.add('active');
    
    activeRow = parseInt(e.target.dataset.row) - 1;
}

function updateRangeDisplay(view) {
    const cells = document.querySelectorAll('.range-cell');
    
    cells.forEach(cell => {
        const selections = JSON.parse(cell.dataset.selections || '[]');
        
        switch(view) {
            case 'row1':
                cell.style.opacity = selections.some(s => s.color === currentColors[0]) ? '1' : '0.3';
                break;
            case 'row2':
                cell.style.opacity = selections.some(s => s.color === currentColors[1]) ? '1' : '0.3';
                break;
            case 'all':
                cell.style.opacity = '1';
                break;
        }
    });
}

// View Mode and Range Builder Toggle Functions
function toggleViewMode() {
    isViewMode = true;
    isRangeBuilderOpen = false;
    
    document.getElementById('viewModeBtn').classList.add('active');
    document.getElementById('rangeBuilderBtn').classList.remove('active');
    
    document.getElementById('sidebar').style.display = 'none';
}

function toggleRangeBuilder() {
    isRangeBuilderOpen = !isRangeBuilderOpen;
    isViewMode = !isRangeBuilderOpen;
    
    document.getElementById('viewModeBtn').classList.toggle('active', !isRangeBuilderOpen);
    document.getElementById('rangeBuilderBtn').classList.toggle('active', isRangeBuilderOpen);
    
    document.getElementById('sidebar').style.display = isRangeBuilderOpen ? 'flex' : 'none';
}

function toggleFormat() {
    currentFormat = currentFormat === 1 ? 2 : 1;
    document.getElementById('formatSwitch').classList.toggle('format-2');
    updateRangeText();
}
        
// Cell and Range Text Functions
function updateRangeText() {
    const cells = [...document.querySelectorAll('.range-cell')];
    let output = '';
    
    const selections = cells
        .filter(cell => {
            const cellSelections = JSON.parse(cell.dataset.selections || '[]');
            if (currentView === 'row1') {
                return cellSelections.some(s => s.color === currentColors[0]);
            } else if (currentView === 'row2') {
                return cellSelections.some(s => s.color === currentColors[1]);
            }
            return cellSelections.length > 0;
        })
        .map(cell => {
            const hand = cell.querySelector('span').textContent;
            const cellSelections = JSON.parse(cell.dataset.selections || '[]');
            
            let weight = 0;
            if (currentView === 'row1') {
                const row1Selection = cellSelections.find(s => s.color === currentColors[0]);
                weight = row1Selection ? row1Selection.weight : 0;
            } else if (currentView === 'row2') {
                const row2Selection = cellSelections.find(s => s.color === currentColors[1]);
                weight = row2Selection ? row2Selection.weight : 0;
            } else {
                weight = Math.min(100, cellSelections.reduce((sum, s) => sum + s.weight, 0));
            }
            
            return { hand, weight };
        })
        .filter(selection => selection.weight > 0);

    if (currentFormat === 1) {
        output = selections
            .map(({ hand, weight }) => `${hand}:${(weight/100).toFixed(3)}`)
            .join(',');
    } else {
        output = selections
            .map(({ hand, weight }) => {
                if (weight === 100) return hand;
                return `[${weight}%]${hand}[/${weight}%]`;
            })
            .join(',');
    }
    
    document.getElementById('rangeText').value = output;
}

function handleRangeTextChange(e) {
    const text = e.target.value.trim();
    
    // Clear all selections first
    document.querySelectorAll('.range-cell').forEach(cell => {
        cell.dataset.selections = JSON.stringify([]);
        updateCellVisual(cell);
    });
    
    if (!text) return;

    // Detect format and parse accordingly
    if (text.includes('[')) {
        // Format 2: bracket format
        const parts = text.split(',');
        parts.forEach(part => {
            part = part.trim();
            if (part.includes('[')) {
                // Match pattern like "[50]AKs[/50]"
                const match = part.match(/\[(\d+)\]([^[]+)\[\/\1\]/) || [];
                if (match && match[1] && match[2]) {
                    const weight = parseInt(match[1]);
                    const hand = match[2].trim();
                    selectHandWithWeight(hand, weight);
                }
            } else {
                // Handle parts without brackets (assumed 100%)
                selectHandWithWeight(part, 100);
            }
        });
    } else {
        // Format 1: decimal format
        const parts = text.split(',');
        parts.forEach(part => {
            const [hand, weightStr] = part.split(':');
            if (hand && weightStr) {
                const weight = Math.round(parseFloat(weightStr) * 100);
                selectHandWithWeight(hand.trim(), weight);
            }
        });
    }
    
    updateStats();
}

function selectHandWithWeight(hand, weight) {
    const cell = [...document.querySelectorAll('.range-cell')]
        .find(cell => cell.querySelector('span').textContent === hand);
    
    if (cell) {
        const selections = JSON.parse(cell.dataset.selections || '[]');
        selections.push({
            color: currentColors[activeRow],
            weight: weight
        });
        cell.dataset.selections = JSON.stringify(selections);
        updateCellVisual(cell);
    }
}
        
// Cell Handling Functions
function selectCell(e) {
    if (!isViewMode) return;
    if (selectedCell) {
        selectedCell.style.outline = 'none';
    }
    selectedCell = e.currentTarget;
    selectedCell.style.outline = '3px solid #4CAF50';
    selectedCell.style.outlineOffset = '-3px';
}

async function saveToCell() {
    if (!selectedCell) {
        alert('Please select a cell first');
        return;
    }
    
    try {
        const rangeText = document.getElementById('rangeText').value || '';
        const currentView = document.querySelector('.three-way-switch').dataset.view || 'all';
        
        // Ensure range display matches current switch position
        updateRangeDisplay(currentView);
        document.querySelectorAll('.range-cell').forEach(cell => updateCellVisual(cell));
        
        // Small delay to ensure visual update is complete
        await new Promise(resolve => setTimeout(resolve, 50));
        
        // Convert current view state to image
        const rangeImage = await convertRangeToImage();
        
        // Save both text and image with explicit String conversions
        const cellDataObj = {
            text: String(rangeText),
            image: String(rangeImage),
            view: String(currentView)
        };
        
        // Store in cell
        const content = selectedCell.querySelector('.cell-content');
        content.innerHTML = '';
        
        // Use safer JSON stringification
        try {
            content.dataset.range = JSON.stringify(cellDataObj);
            content.classList.add('has-range');
            
            // Add hover functionality
            addCellHover(selectedCell);
            
            toggleRangeBuilder();
        } catch (jsonError) {
            console.error('JSON error in saveToCell:', jsonError);
            alert('Error saving range data: ' + jsonError.message);
        }
    } catch (error) {
        console.error('Save error:', error);
        alert('Error saving to cell: ' + error.message);
    }
}

function clearSelection() {
    document.querySelectorAll('.range-cell').forEach(cell => {
        cell.dataset.selections = JSON.stringify([]);
        updateCellVisual(cell);
    });
    document.getElementById('rangeText').value = '';
    updateStats();
}

function handleDragStart(e) {
    if (!isViewMode) return;
    e.dataTransfer.setData('text/plain', e.target.dataset.id);
}

function handleDragOver(e) {
    if (!isViewMode) return;
    e.preventDefault();
}

function handleDrop(e) {
    if (!isViewMode) return;
    e.preventDefault();
    const sourceId = e.dataTransfer.getData('text/plain');
    const targetId = e.target.closest('.cell').dataset.id;
    
    const sourceData = cellData.get(sourceId);
    const targetData = cellData.get(targetId);
    
    if (sourceData) cellData.set(targetId, sourceData);
    if (targetData) cellData.set(sourceId, targetData);
    
    updateCellContent(sourceId);
    updateCellContent(targetId);
}

function updateCellContent(cellId) {
    const cell = document.querySelector(`[data-id="${cellId}"]`);
    const content = cell.querySelector('.cell-content');
    const data = cellData.get(cellId);
    
    if (data) {
        content.textContent = data;
    } else {
        content.innerHTML = '';
    }
}

// Weight and Color Settings Functions
function updateWeight(value, rowIndex) {
    const adjustedIndex = rowIndex - 1;
    currentWeights[adjustedIndex] = Math.min(Math.max(0, parseInt(value)), 100);
    document.getElementById(`weightInput${rowIndex}`).value = currentWeights[adjustedIndex];
    activeRow = adjustedIndex;
    saveColorSettings(adjustedIndex);
    updateStats();
}

function saveColorSettings(rowIndex) {
    const color = currentColors[rowIndex];
    const weight = currentWeights[rowIndex];
    localStorage.setItem(`savedColor${rowIndex + 1}`, JSON.stringify({ color, weight }));
}

function loadSavedColors() {
    for (let i = 1; i <= 2; i++) {
        const saved = localStorage.getItem(`savedColor${i}`);
        if (saved) {
            const { color, weight } = JSON.parse(saved);
            const button = document.getElementById(`colorPicker${i}`);
            button.querySelector('.current-color').style.backgroundColor = color;
            document.getElementById(`weightInput${i}`).value = weight;
            currentColors[i - 1] = color;
            currentWeights[i - 1] = weight;
        }
    }
}

// Add these new functions
function convertRangeToImage() {
    const rangeGrid = document.getElementById('rangeGrid');
    if (!rangeGrid) {
        console.error('Range grid element not found');
        return '';
    }
    
    return html2canvas(rangeGrid, {
        allowTaint: true,
        useCORS: true,
        logging: false
    })
    .then(canvas => {
        try {
            return canvas.toDataURL('image/png');
        } catch (error) {
            console.error('Canvas to data URL error:', error);
            return '';
        }
    })
    .catch(error => {
        console.error('HTML2Canvas error:', error);
        return '';
    });
}

function addCellHover(cell) {
    cell.addEventListener('mouseenter', () => {
        try {
            const content = cell.querySelector('.cell-content');
            if (!content || !content.dataset.range) return;

            let rangeData;
            try {
                rangeData = JSON.parse(content.dataset.range);
            } catch (parseError) {
                console.error('Error parsing range data:', parseError);
                return;
            }
            
            if (rangeData && rangeData.image) {
                const img = new Image();
                img.onerror = () => console.error('Error loading range image');
                img.src = rangeData.image;
                
                hoverPopup.innerHTML = '';
                hoverPopup.appendChild(img);
                
                // Position popup
                const cellRect = cell.getBoundingClientRect();
                hoverPopup.style.left = `${cellRect.right + 5}px`;
                hoverPopup.style.top = `${cellRect.top}px`;
                hoverPopup.style.display = 'block';
            }
        } catch (error) {
            console.error('Hover display error:', error);
        }
    });
    
    cell.addEventListener('mouseleave', () => {
        hoverPopup.style.display = 'none';
        hoverPopup.innerHTML = '';
    });
}

function copyCell(cell) {
    const content = cell.querySelector('.cell-content');
    return {
        text: content.textContent,
        backgroundColor: cell.style.backgroundColor,
        textColor: content.style.color,
        rangeData: content.dataset.range || '',
        hasRange: content.classList.contains('has-range')
    };
}

function clearCell(cell) {
    const content = cell.querySelector('.cell-content');
    content.innerHTML = '';
    content.dataset.range = '';
    content.classList.remove('has-range');
    cell.style.backgroundColor = '';
    content.style.color = '';
    cellData.delete(cell.dataset.id);
}

function pasteCell(cell, data) {
    if (!data) return;
    
    const content = cell.querySelector('.cell-content');
    content.textContent = data.text;
    cell.style.backgroundColor = data.backgroundColor;
    content.style.color = data.textColor;
    
    if (data.rangeData) {
        content.dataset.range = data.rangeData;
        if (data.hasRange) {
            content.classList.add('has-range');
            addCellHover(cell);
        }
    }
    
    if (data.text || data.rangeData) {
        cellData.set(cell.dataset.id, data.text);
    }
}
        
// Initialization
document.addEventListener('DOMContentLoaded', () => {
    createGrid();
    createRangeGrid();
    toggleViewMode();
    
    // Add global keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (selectedCell && e.ctrlKey && !selectedCell.querySelector('input')) {
            switch(e.key.toLowerCase()) {
                case 'c':
                    e.preventDefault();
                    clipboardData = copyCell(selectedCell);
                    break;
                case 'x':
                    e.preventDefault();
                    clipboardData = copyCell(selectedCell);
                    clearCell(selectedCell);
                    break;
                case 'v':
                    e.preventDefault();
                    pasteCell(selectedCell, clipboardData);
                    break;
            }
        }
    });
    
    // Color picker event listeners
    document.getElementById('colorPicker1').addEventListener('click', handleColorPickerClick);
    document.getElementById('colorPicker2').addEventListener('click', handleColorPickerClick);
    
    // Three-way switch handler
    const threeWaySwitch = document.querySelector('.three-way-switch');
    threeWaySwitch.dataset.view = 'all'; // Default position
    
    threeWaySwitch.addEventListener('click', (e) => {
        const rect = threeWaySwitch.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const width = rect.width;
        
        let newView;
        if (x < width / 3) {
            newView = 'row1';
        } else if (x < (width * 2) / 3) {
            newView = 'all';
        } else {
            newView = 'row2';
        }
        
        threeWaySwitch.dataset.view = newView;
        currentView = newView;
        updateRangeDisplay(newView);
        document.querySelectorAll('.range-cell').forEach(cell => updateCellVisual(cell));
        updateRangeText();
    });
    
    document.querySelectorAll('.row-toggle').forEach(button => {
        button.addEventListener('click', handleRowToggle);
    });
    
    // Event delegation for color swatches
    document.addEventListener('click', e => {
        const swatch = e.target.closest('.color-swatch');
        if (swatch) {
            const color = swatch.dataset.color;
            const rowIndex = parseInt(swatch.dataset.rowIndex);
            selectColor(color, rowIndex);
        }
    });
    
    // Add format switch event listener
    document.getElementById('formatSwitch').addEventListener('click', toggleFormat);
    
    loadSavedColors();
    initializeDragging();

    // Fix for range text copying
    document.getElementById('rangeText').addEventListener('copy', (e) => {
        e.preventDefault();
        const text = e.target.value.slice(e.target.selectionStart, e.target.selectionEnd);
        e.clipboardData.setData('text/plain', text);
    });
    
    // Add JSON export/import functionality
    document.getElementById('exportJsonBtn').addEventListener('click', exportToJson);
    document.getElementById('importJsonBtn').addEventListener('click', () => {
        // Create a new file input each time to avoid browser caching issues
        const oldInput = document.getElementById('jsonFileInput');
        const newInput = document.createElement('input');
        newInput.type = 'file';
        newInput.id = 'jsonFileInput';
        newInput.accept = '.json';
        newInput.style.display = 'none';
        
        // Replace old input with new one
        if (oldInput) {
            oldInput.parentNode.replaceChild(newInput, oldInput);
        } else {
            document.body.appendChild(newInput);
        }
        
        // Add event listener to new input
        newInput.addEventListener('change', importFromJson);
        
        // Trigger click on new input
        newInput.click();
    });
});
</script>
</body>
</html>
